```python
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
```


```python
# 만약 이렇게 구현 할 시 x는 실수값만 받을 수 있고
# 넘파이 형태 데이터를 받을 수 없음
def step_function(x):
    if x > 0:
        return 1
    elif x<=0:
        return 0
```


```python
def step_function_for_numpy(x):
    return np.array( x > 0 , dtype=np.int)
    
```


```python
x = np.arange(-5.,5.,.1) # np.arange(start,stop,step) [start,stop)
# y = step_function(x) 
y = step_function_for_numpy(x)
plt.plot(x,y)
plt.ylim(-.1,1.1)
plt.vlines(0,ymin=-0.05,ymax=1.05,linestyles='dashed',colors='r')
plt.show()

```

    /var/folders/6b/vq51j9_153n_8c0d82cvxh7w0000gn/T/ipykernel_3726/2335393025.py:2: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
    Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
      return np.array( x > 0 , dtype=np.int)



    
![png](output_3_1.png)
    



```python
def sigmoid(x):
    y = 1 / (1+np.exp(-x))
    return y
```


```python
x = np.arange(-5.,5.,.1)
y = sigmoid(x)
plt.plot(x,y)
plt.ylim(-.1,1.1)
plt.hlines(0.5,-4.9,4.9,linestyles='dashed',color='r')
plt.hlines(0,-5,5,color='k')
plt.vlines(0,0,1.05,color='k')
plt.show()
```


    
![png](output_5_0.png)
    



```python
def ReLU_for_numpy(x):
    return np.maximum(0,x)
def ReLU(x):
    return max(0,x)


```


```python
x = np.arange(-5.,5.,.1)
#y = ReLU(x)
y = ReLU_for_numpy(x)

plt.plot(x,y,linewidth=5)
plt.ylim(-.1,5)
plt.hlines(0,-5,5,colors='k')
plt.vlines(0,0,4.9,colors='k')
plt.show()
```


    
![png](output_7_0.png)
    



```python
a1 = np.array([1,2])
a2 = np.array([[1,2]])
a3 = np.array([[1],[2]])
print(a1,' np.ndim:',np.ndim(a1),' a1.shape:',a1.shape)
print(a2,' np.ndim:',np.ndim(a2),' a1.shape:',a2.shape)
print(a3,' np.ndim:',np.ndim(a3),' a1.shape:',a3.shape)
```

    [1 2]  np.ndim: 1  a1.shape: (2,)
    [[1 2]]  np.ndim: 2  a1.shape: (1, 2)
    [[1]
     [2]]  np.ndim: 2  a1.shape: (2, 1)



```python
a = np.array([[1,2],[3,4]])
b = np.array([[2,3],[5,7]])
np.dot(a,b),np.dot(b,a)
```




    (array([[12, 17],
            [26, 37]]),
     array([[11, 16],
            [26, 38]]))




```python
a = np.array([[1,2],[3,4]])
b = np.array([[2,3],[4,5],[6,7]])
print(a,a.shape)
print(b,b.shape)
np.dot(a,b)
```

    [[1 2]
     [3 4]] (2, 2)
    [[2 3]
     [4 5]
     [6 7]] (3, 2)



    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    /Users/shin98/Desktop/DL/zerotoall_DL/Shin/Chapter_3/chapter_3.ipynb Cell 11 in <cell line: 5>()
          <a href='vscode-notebook-cell:/Users/shin98/Desktop/DL/zerotoall_DL/Shin/Chapter_3/chapter_3.ipynb#X14sZmlsZQ%3D%3D?line=2'>3</a> print(a,a.shape)
          <a href='vscode-notebook-cell:/Users/shin98/Desktop/DL/zerotoall_DL/Shin/Chapter_3/chapter_3.ipynb#X14sZmlsZQ%3D%3D?line=3'>4</a> print(b,b.shape)
    ----> <a href='vscode-notebook-cell:/Users/shin98/Desktop/DL/zerotoall_DL/Shin/Chapter_3/chapter_3.ipynb#X14sZmlsZQ%3D%3D?line=4'>5</a> np.dot(a,b)


    File <__array_function__ internals>:5, in dot(*args, **kwargs)


    ValueError: shapes (2,2) and (3,2) not aligned: 2 (dim 1) != 3 (dim 0)



```python
a= np.array([1,2,3,4])
b= np.array([1,1,2,2])
print(np.dot(a,b))
print(np.dot(b,a))
```

    17
    17



```python
a = np.array([[1,2]])
b = np.array([[2,3],[2,3]])
print(np.ndim(a),np.ndim(b))
print(a.shape,b.shape)
print(np.dot(a,b))
print(a@b)
print(np.matmul(a,b)) 
# matmul 이나 @ 를 사용하라는 이유 -> matrix multiplication 전용이기 때문
# dot 함수는 내적을 수행
```

    2 2
    (1, 2) (2, 2)
    [[6 9]]
    [[6 9]]
    [[6 9]]



```python
a=np.array([1,2])
b=np.array(3)
np.dot(a,b),a*b
```




    (array([3, 6]), array([3, 6]))




```python
a= np.array([[[1,2],[3,4],[5,6]],
             [[1,2],[3,4],[5,6]]])
print(a.shape)
print(a)
```

    (2, 3, 2)
    [[[1 2]
      [3 4]
      [5 6]]
    
     [[1 2]
      [3 4]
      [5 6]]]



```python
b = np.array([1,2])
print(np.dot(a,b).shape)
print(np.dot(a,b))
print(np.sum(a*b,axis=-1))
```

    (2, 3)
    [[ 5 11 17]
     [ 5 11 17]]
    [[ 5 11 17]
     [ 5 11 17]]



```python
a = np.array([[[1,2,3],[1,2,3]]])
b = np.array([[[1,2],[1,2],[1,2]]])
print(a.shape,b.shape)
print(np.dot(a,b).shape)
print(np.dot(a,b))
print(np.dot(b,a)) # b.shape=(1,3,2) a.shape=(1,2,3) 

```

    (1, 2, 3) (1, 3, 2)
    (1, 2, 1, 2)
    [[[[ 6 12]]
    
      [[ 6 12]]]]
    [[[[3 6 9]]
    
      [[3 6 9]]
    
      [[3 6 9]]]]



```python
X = np.array([1,2]) # [x1,x2]

W = np.array([[1,3,5],
              [2,4,6]])

print(X.shape)
print(W.shape)


```

    (2,)
    (2, 3)



```python
y=np.dot(X,W)
print(y)
print(y.shape)
```

    [ 5 11 17]
    (3,)



```python
def identity_function(x):
    return x 
```


```python
def init_network():
    network={}
    network['W1']=np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]])
    network['b1']=np.array([0.1,0.2,0.3])
    network['W2']=np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])
    network['b2']=np.array([0.1,0.2])
    network['W3']=np.array([[0.1,0.3],[0.2,0.4]])
    network['b3']=np.array([0.1,0.3])
    return network

def forward(X,network):
    W1,W2,W3 = network['W1'],network['W2'],network['W3']
    b1,b2,b3 = network['b1'],network['b2'],network['b3']

    a1 = np.dot(X,W1)+b1
    z1 = sigmoid(a1)
    a2 = np.dot(z1,W2)+b2
    z2 = sigmoid(a2)
    a3 = np.dot(z2,W3)+b3
    y = identity_function(a3)

    return y
 

```


```python
network = init_network()
X = np.array([1.,.5])
y = forward(X,network)
print(y)

```

    [0.31682708 0.79627909]



```python
def softmax(a):
    c = np.max(a)
    exp_a = np.exp(a-c)
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a

    return y
```


```python

```
